"""Type stubs for CasADi to fix false positive type errors.

CasADi's Python bindings are SWIG-generated and lack proper type annotations.
These minimal stubs provide correct signatures for the most commonly used
functions to silence type checker errors.
"""

from __future__ import annotations

from collections.abc import Sequence
from typing import Any

class Sparsity:
    """CasADi sparsity pattern."""

    @staticmethod
    def dense(nrow: int, ncol: int = 1) -> Sparsity:
        """Create a dense sparsity pattern."""
        ...

    def __init__(self, nrow: int = 0, ncol: int = 1) -> None: ...
    def nnz(self) -> int: ...
    def size1(self) -> int: ...
    def size2(self) -> int: ...

class DM:
    """CasADi dense matrix (numeric)."""

    def __init__(self, *args: Any) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def full(self) -> Any: ...
    def T(self) -> DM: ...
    @property
    def shape(self) -> tuple[int, int]: ...
    def size1(self) -> int: ...
    def size2(self) -> int: ...

class SX:
    """CasADi symbolic expression (scalar/matrix)."""

    @staticmethod
    def sym(name: str, *args: int) -> SX:
        """Create a symbolic variable.

        Args:
            name: Variable name
            *args: Dimensions (n,) for vector, (n, m) for matrix
        """
        ...

    @staticmethod
    def zeros(*args: int) -> SX: ...
    @staticmethod
    def ones(*args: int) -> SX: ...
    def __init__(self, *args: Any) -> None: ...
    def __getitem__(self, key: Any) -> SX: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __add__(self, other: Any) -> SX: ...
    def __radd__(self, other: Any) -> SX: ...
    def __sub__(self, other: Any) -> SX: ...
    def __rsub__(self, other: Any) -> SX: ...
    def __mul__(self, other: Any) -> SX: ...
    def __rmul__(self, other: Any) -> SX: ...
    def __truediv__(self, other: Any) -> SX: ...
    def __rtruediv__(self, other: Any) -> SX: ...
    def __pow__(self, other: Any) -> SX: ...
    def __neg__(self) -> SX: ...
    def T(self) -> SX: ...
    @property
    def shape(self) -> tuple[int, int]: ...
    def size1(self) -> int: ...
    def size2(self) -> int: ...
    def numel(self) -> int: ...

class MX:
    """CasADi symbolic expression (graph-based)."""

    @staticmethod
    def sym(name: str, *args: int) -> MX: ...
    @staticmethod
    def zeros(*args: int) -> MX: ...
    @staticmethod
    def ones(*args: int) -> MX: ...
    def __init__(self, *args: Any) -> None: ...
    def __getitem__(self, key: Any) -> MX: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __add__(self, other: Any) -> MX: ...
    def __radd__(self, other: Any) -> MX: ...
    def __sub__(self, other: Any) -> MX: ...
    def __rsub__(self, other: Any) -> MX: ...
    def __mul__(self, other: Any) -> MX: ...
    def __rmul__(self, other: Any) -> MX: ...
    def __truediv__(self, other: Any) -> MX: ...
    def __rtruediv__(self, other: Any) -> MX: ...
    def __pow__(self, other: Any) -> MX: ...
    def __neg__(self) -> MX: ...
    def T(self) -> MX: ...
    @property
    def shape(self) -> tuple[int, int]: ...
    def size1(self) -> int: ...
    def size2(self) -> int: ...

class Function:
    """CasADi function object."""

    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
    def n_in(self) -> int: ...
    def n_out(self) -> int: ...
    def name_in(self, i: int = 0) -> str: ...
    def name_out(self, i: int = 0) -> str: ...
    def size_in(self, i: int = 0) -> tuple[int, int]: ...
    def size_out(self, i: int = 0) -> tuple[int, int]: ...
    def jacobian(self) -> Function: ...
    def hessian(self) -> Function: ...

class Callback:
    """CasADi callback base class."""

    def __init__(self) -> None: ...
    def construct(self, name: str, opts: dict[str, Any] | None = None) -> None: ...
    def get_n_in(self, *args: Any) -> int: ...
    def get_n_out(self, *args: Any) -> int: ...
    def get_sparsity_in(self, *args: Any) -> Sparsity: ...
    def get_sparsity_out(self, *args: Any) -> Sparsity: ...
    def eval(self, *args: Any) -> list[DM]: ...
    def get_name_in(self, i: int) -> str: ...
    def get_name_out(self, i: int) -> str: ...

# NLP solver functions
def nlpsol(
    name: str,
    solver: str,
    nlp: dict[str, Any],
    opts: dict[str, Any] | None = None,
) -> Function:
    """Create an NLP solver.

    Args:
        name: Solver name
        solver: Solver plugin (e.g., "ipopt")
        nlp: NLP definition dict with keys "x", "f", "g"
        opts: Solver options
    """
    ...

def nlpsol_out(*args: Any) -> Sequence[str]:
    """Get NLP solver output names."""
    ...

def nlpsol_in(*args: Any) -> Sequence[str]:
    """Get NLP solver input names."""
    ...

def nlpsol_plugins() -> list[str]:
    """Get available NLP solver plugins."""
    ...

# Math functions (symbolic)
def sin(x: SX | MX | float) -> SX | MX: ...
def cos(x: SX | MX | float) -> SX | MX: ...
def tan(x: SX | MX | float) -> SX | MX: ...
def asin(x: SX | MX | float) -> SX | MX: ...
def acos(x: SX | MX | float) -> SX | MX: ...
def atan(x: SX | MX | float) -> SX | MX: ...
def atan2(y: SX | MX | float, x: SX | MX | float) -> SX | MX: ...
def exp(x: SX | MX | float) -> SX | MX: ...
def log(x: SX | MX | float) -> SX | MX: ...
def sqrt(x: SX | MX | float) -> SX | MX: ...
def fabs(x: SX | MX | float) -> SX | MX: ...
def floor(x: SX | MX | float) -> SX | MX: ...
def ceil(x: SX | MX | float) -> SX | MX: ...
def fmin(x: SX | MX | float, y: SX | MX | float) -> SX | MX: ...
def fmax(x: SX | MX | float, y: SX | MX | float) -> SX | MX: ...
def if_else(cond: SX | MX, x: SX | MX, y: SX | MX, short_circuit: bool = False) -> SX | MX: ...

# Linear algebra
def mtimes(a: SX | MX | DM, b: SX | MX | DM) -> SX | MX | DM: ...
def dot(a: SX | MX | DM, b: SX | MX | DM) -> SX | MX | DM: ...
def cross(a: SX | MX | DM, b: SX | MX | DM, dim: int = -1) -> SX | MX | DM: ...
def norm_2(x: SX | MX | DM) -> SX | MX | DM: ...
def norm_1(x: SX | MX | DM) -> SX | MX | DM: ...
def norm_inf(x: SX | MX | DM) -> SX | MX | DM: ...
def sum1(x: SX | MX | DM) -> SX | MX | DM: ...
def sum2(x: SX | MX | DM) -> SX | MX | DM: ...

# Matrix operations
def vertcat(*args: SX | MX | DM) -> SX | MX | DM: ...
def horzcat(*args: SX | MX | DM) -> SX | MX | DM: ...
def reshape(x: SX | MX | DM, nrow: int, ncol: int) -> SX | MX | DM: ...
def vec(x: SX | MX | DM) -> SX | MX | DM: ...
def repmat(x: SX | MX | DM, n: int, m: int = 1) -> SX | MX | DM: ...
def jacobian(ex: SX | MX, arg: SX | MX) -> SX | MX: ...
def hessian(ex: SX | MX, arg: SX | MX) -> tuple[SX | MX, SX | MX]: ...
def gradient(ex: SX | MX, arg: SX | MX) -> SX | MX: ...
def substitute(ex: SX | MX, v: SX | MX, vdef: SX | MX) -> SX | MX: ...

# Constants
inf: float
pi: float
