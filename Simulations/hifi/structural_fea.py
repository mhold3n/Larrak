"""3D Structural FEA Adapter (CalculiX via Docker).

High-fidelity stress and contact analysis for:
- Piston thermal stress and distortion
- Ring-liner contact pressure distribution
- Gear tooth bending/contact stress

Uses: docker run calculix/ccx ccx -i <model>
"""

import json
import subprocess
from pathlib import Path
from typing import Any

from Simulations.common.io_schema import SimulationOutput
from Simulations.hifi.base import ExternalSolverAdapter, ExternalSolverConfig, SolverBackend


class StructuralFEAConfig(ExternalSolverConfig):
    """Configuration for structural FEA solver."""

    backend: SolverBackend = SolverBackend.CALCULIX

    # Docker settings
    docker_image: str = "calculix/ccx:latest"

    # Analysis type
    analysis_type: str = "static"  # "static", "modal", "transient"
    include_thermal_load: bool = True
    include_contact: bool = False

    # Material model
    material_model: str = "elastic"  # "elastic", "elastoplastic"

    # Mesh refinement zones
    refine_contact_zone: bool = True
    contact_element_size_mm: float = 0.5


class StructuralFEAAdapter(ExternalSolverAdapter):
    """
    3D Structural FEA wrapper using CalculiX via Docker.

    Workflow:
    1. Generate mesh from geometry (Gmsh)
    2. Write CalculiX input deck (.inp)
    3. Run ccx in Docker container
    4. Parse .dat and .frd output files
    """

    def __init__(self, name: str = "structural_fea", config: StructuralFEAConfig | None = None):
        super().__init__(name, config or StructuralFEAConfig())
        self.config: StructuralFEAConfig = self.config

    def _generate_mesh(self):
        """Generate 3D mesh using Gmsh."""
        from Simulations.hifi.mesh import GmshMesher, MeshConfig

        geo = self.input_data.geometry

        mesh_config = MeshConfig(
            element_size_min=self.config.contact_element_size_mm / 1000,
            element_size_max=5e-3,
        )
        mesher = GmshMesher(mesh_config)

        msh_file = self.case_dir / "model.msh"
        result = mesher.create_piston_3d(
            bore=geo.bore,
            crown_thickness=0.015,  # Default crown thickness
            skirt_length=0.05,
            output_path=str(msh_file),
        )

        # Export to CalculiX format
        inp_file = self.case_dir / "mesh.inp"
        mesher.export_calculix(str(msh_file), str(inp_file))

        self.mesh_info = result
        self.mesh_file = inp_file
        print(
            f"[{self.name}] Generated mesh: {result['n_nodes']} nodes, {result['n_elements']} elements"
        )

    def _write_input_files(self):
        """Write CalculiX input deck."""
        geo = self.input_data.geometry
        bcs = self.input_data.boundary_conditions

        # Material properties (aluminum 6061-T6)
        youngs_modulus = 70e9  # Pa
        poisson_ratio = 0.33
        density = 2700  # kg/m³
        thermal_expansion = 23e-6  # 1/K

        # Get thermal load if enabled
        T_ref = 300.0  # Reference temperature
        T_load = max(bcs.temperature_gas) if bcs.temperature_gas else 500.0

        # Get pressure load
        p_max = max(bcs.pressure_gas) if bcs.pressure_gas else 50e5

        inp_file = self.case_dir / "model.inp"

        with open(inp_file, "w") as f:
            f.write("** CalculiX Input Deck - Generated by Larrak\n")
            f.write("** Piston Structural Analysis\n")
            f.write("**\n")

            # Include mesh
            f.write("*INCLUDE, INPUT=mesh.inp\n")
            f.write("**\n")

            # Material definition
            f.write("*MATERIAL, NAME=ALUMINUM\n")
            f.write("*ELASTIC\n")
            f.write(f"{youngs_modulus:.3e}, {poisson_ratio}\n")
            f.write("*DENSITY\n")
            f.write(f"{density}\n")
            f.write("*EXPANSION\n")
            f.write(f"{thermal_expansion}\n")
            f.write("**\n")

            # Assign material to all elements
            f.write("*SOLID SECTION, ELSET=EALL, MATERIAL=ALUMINUM\n")
            f.write("**\n")

            # Initial conditions (MUST be before *STEP)
            if self.config.include_thermal_load:
                f.write("*INITIAL CONDITIONS, TYPE=TEMPERATURE\n")
                f.write(f"NALL, {T_ref}\n")
                f.write("**\n")

            # Boundary conditions - fix bottom nodes in Z direction
            f.write("** Fix Z displacement on bottom nodes\n")
            f.write("*BOUNDARY\n")
            f.write("NALL, 3, 3\n")
            f.write("**\n")

            # Step definition
            f.write("*STEP\n")
            f.write("*STATIC\n")

            if self.config.include_thermal_load:
                # Apply thermal load
                f.write("*TEMPERATURE\n")
                f.write(f"NALL, {T_load}\n")

            # Pressure load on crown (distributed load on face 3 = +Z)
            f.write("*DLOAD\n")
            f.write(f"EALL, P3, {p_max:.3e}\n")

            # Output requests
            f.write("*NODE FILE\n")
            f.write("U, NT\n")
            f.write("*EL FILE\n")
            f.write("S, E\n")
            f.write("*NODE PRINT, NSET=NALL\n")
            f.write("U\n")
            f.write("*EL PRINT, ELSET=EALL\n")
            f.write("S\n")
            f.write("*END STEP\n")

        print(f"[{self.name}] Wrote input deck: {inp_file}")

    def _run_solver(self) -> int:
        """Execute CalculiX via Docker."""
        model_name = "model"

        # Docker command with volume mount
        cmd = [
            "docker",
            "run",
            "--rm",
            "-v",
            f"{self.case_dir}:/work",
            "-w",
            "/work",
            self.config.docker_image,
            "ccx",
            "-i",
            model_name,
        ]

        print(f"[{self.name}] Running: {' '.join(cmd)}")

        try:
            result = subprocess.run(
                cmd, capture_output=True, text=True, timeout=self.config.timeout_seconds
            )

            # Save output for debugging
            (self.case_dir / "ccx_stdout.log").write_text(result.stdout)
            (self.case_dir / "ccx_stderr.log").write_text(result.stderr)

            if result.returncode != 0:
                print(f"[{self.name}] CalculiX error: {result.stderr[:500]}")

            return result.returncode

        except subprocess.TimeoutExpired:
            print(f"[{self.name}] CalculiX timed out after {self.config.timeout_seconds}s")
            return -1
        except FileNotFoundError:
            print(f"[{self.name}] Docker not found. Is Docker running?")
            return -2

    def _parse_output_files(self) -> dict[str, Any]:
        """Parse CalculiX results from .dat file."""
        dat_file = self.case_dir / "model.dat"
        frd_file = self.case_dir / "model.frd"

        results = {
            "von_mises_max_mpa": 0.0,
            "displacement_max_mm": 0.0,
            "safety_factor": 0.0,
        }

        # Parse .dat file for stress summary
        if dat_file.exists():
            content = dat_file.read_text()

            # Look for maximum stress in output
            # CalculiX outputs stress in element format
            lines = content.split("\n")
            stresses = []

            for line in lines:
                # Parse stress values from S output
                parts = line.split()
                if len(parts) >= 7:
                    try:
                        # von Mises is typically in a specific column
                        s_vm = float(parts[-1])
                        stresses.append(abs(s_vm))
                    except ValueError:
                        continue

            if stresses:
                max_stress_pa = max(stresses)
                results["von_mises_max_mpa"] = max_stress_pa / 1e6

                # Safety factor (assuming 280 MPa yield for 6061-T6)
                yield_strength = 280e6
                results["safety_factor"] = yield_strength / max(max_stress_pa, 1e6)

        # Parse .frd for displacements (binary format - simplified)
        if frd_file.exists():
            # For now, use placeholder - full .frd parsing requires pyvista or similar
            results["displacement_max_mm"] = 0.05  # Placeholder

        print(
            f"[{self.name}] Results: σ_max={results['von_mises_max_mpa']:.1f} MPa, SF={results['safety_factor']:.2f}"
        )

        return results

    def solve_steady_state(self) -> SimulationOutput:
        """Run structural FEA and return standardized output."""
        success = self.execute()

        return SimulationOutput(
            run_id=self.input_data.run_id if self.input_data else "structural_run",
            success=success,
            calibration_params=self.results,
        )
